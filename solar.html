<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solar Vortex: Mobile Edition</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevents browser pull-to-refresh and scroll */
        }
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            max-width: 80%;
        }
        #hud {
            position: absolute;
            bottom: 15px;
            right: 15px;
            color: #4da6ff;
            text-align: right;
            font-size: 10px;
            background: rgba(0,0,0,0.5);
            padding: 8px 12px;
            border-radius: 20px;
            pointer-events: none;
            border: 1px solid rgba(77, 166, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <h1 style="margin:0; font-size: 1.2rem;">The Galactic Vortex</h1>
        <p style="margin:3px 0; font-size: 0.8rem; opacity: 0.7;">Sun & Planets: 230 km/s</p>
    </div>
    <div id="hud">
        Move: 1 Finger<br>
        Zoom: Pinch
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, sun, starField, sunTrail;
        const planets = [];
        const sunTrailPoints = [];
        const sunVelocity = 0.8; 
        const orbitTilt = Math.PI / 3; 
        let time = 0;

        // Interaction state
        let isUserInteracting = false;
        let lastMouseX = 0, lastMouseY = 0;
        let targetRotationX = 0.5, targetRotationY = 0.8;
        let zoom = 400;
        let lastPinchDist = 0;

        function createLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.font = 'Bold 44px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.fillText(text, 128, 45);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(18, 4.5, 1);
            return sprite;
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for mobile performance
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 2, 2000);
            scene.add(pointLight);

            // --- Sun ---
            sun = new THREE.Mesh(
                new THREE.SphereGeometry(12, 24, 24),
                new THREE.MeshBasicMaterial({ color: 0xffdd44 })
            );
            scene.add(sun);
            sun.add(createLabel("SUN"));

            const glow = new THREE.Mesh(
                new THREE.SphereGeometry(18, 24, 24),
                new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.2 })
            );
            sun.add(glow);

            sunTrail = new THREE.Line(
                new THREE.BufferGeometry(),
                new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.3 })
            );
            scene.add(sunTrail);

            // --- Grid ---
            const gridHelper = new THREE.GridHelper(6000, 40, 0x444444, 0x222222);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);

            // --- Planets ---
            const planetData = [
                { name: "Merc", dist: 30, size: 1.2, speed: 0.047, color: 0xaaaaaa },
                { name: "Venus", dist: 45, size: 2.4, speed: 0.035, color: 0xe3bb76 },
                { name: "Earth", dist: 65, size: 2.5, speed: 0.029, color: 0x2277ff },
                { name: "Mars", dist: 85, size: 1.8, speed: 0.024, color: 0xff4422 },
                { name: "Jup", dist: 130, size: 8.0, speed: 0.013, color: 0xd39c7e },
                { name: "Sat", dist: 180, size: 7.0, speed: 0.009, color: 0xc5ab6e, ring: true },
                { name: "Uran", dist: 230, size: 4.0, speed: 0.006, color: 0xbbeeff },
                { name: "Nept", dist: 280, size: 3.8, speed: 0.005, color: 0x4466ff }
            ];

            planetData.forEach(data => {
                const mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(data.size, 16, 16),
                    new THREE.MeshStandardMaterial({ color: data.color })
                );
                mesh.add(createLabel(data.name));
                
                const trailLine = new THREE.Line(
                    new THREE.BufferGeometry(),
                    new THREE.LineBasicMaterial({ color: data.color, transparent: true, opacity: 0.3 })
                );
                scene.add(trailLine);

                const orbitRing = new THREE.Mesh(
                    new THREE.RingGeometry(data.dist - 0.2, data.dist + 0.2, 64),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.05, side: THREE.DoubleSide })
                );
                orbitRing.rotation.x = orbitTilt;
                scene.add(orbitRing);

                if (data.ring) {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(data.size + 2, data.size + 7, 32),
                        new THREE.MeshBasicMaterial({ color: 0x887755, side: THREE.DoubleSide, transparent: true, opacity: 0.4 })
                    );
                    ring.rotation.x = Math.PI / 3;
                    mesh.add(ring);
                }

                planets.push({ mesh, trail: trailLine, trailPoints: [], orbitRing, dist: data.dist, speed: data.speed, angle: Math.random() * Math.PI * 2 });
                scene.add(mesh);
            });

            // --- Stars ---
            const starCoords = [];
            for (let i = 0; i < 5000; i++) {
                starCoords.push((Math.random() - 0.5) * 10000, (Math.random() - 0.5) * 10000, (Math.random() - 0.5) * 10000);
            }
            const starGeo = new THREE.BufferGeometry();
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
            starField = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 2 }));
            scene.add(starField);

            // --- Mobile Event Listeners ---
            window.addEventListener('resize', onWindowResize);
            
            // Interaction logic
            const startInput = (x, y) => { isUserInteracting = true; lastMouseX = x; lastMouseY = y; };
            const moveInput = (x, y) => {
                if (!isUserInteracting) return;
                targetRotationY += (x - lastMouseX) * 0.007;
                targetRotationX += (y - lastMouseY) * 0.007;
                lastMouseX = x; lastMouseY = y;
            };
            const endInput = () => { isUserInteracting = false; lastPinchDist = 0; };

            // Mouse
            document.addEventListener('mousedown', (e) => startInput(e.clientX, e.clientY));
            document.addEventListener('mousemove', (e) => moveInput(e.clientX, e.clientY));
            document.addEventListener('mouseup', endInput);
            document.addEventListener('wheel', (e) => { zoom += e.deltaY * 0.3; zoom = Math.max(100, Math.min(3000, zoom)); });

            // Touch
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    startInput(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    lastPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                }
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    moveInput(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    if (lastPinchDist > 0) {
                        zoom -= (dist - lastPinchDist) * 2;
                        zoom = Math.max(100, Math.min(3000, zoom));
                    }
                    lastPinchDist = dist;
                }
            }, { passive: false });

            document.addEventListener('touchend', endInput);

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            sun.position.z += sunVelocity;
            
            camera.position.x = sun.position.x + zoom * Math.sin(targetRotationY) * Math.cos(targetRotationX);
            camera.position.z = sun.position.z + zoom * Math.cos(targetRotationY) * Math.cos(targetRotationX);
            camera.position.y = sun.position.y + zoom * Math.sin(targetRotationX);
            camera.lookAt(sun.position);

            sunTrailPoints.push(sun.position.clone());
            if (sunTrailPoints.length > 300) sunTrailPoints.shift();
            sunTrail.geometry.setFromPoints(sunTrailPoints);

            planets.forEach(p => {
                p.angle += p.speed;
                p.orbitRing.position.z = sun.position.z;
                const lx = Math.cos(p.angle) * p.dist;
                const ly = Math.sin(p.angle) * p.dist;
                p.mesh.position.set(sun.position.x + lx, sun.position.y + ly * Math.cos(orbitTilt), sun.position.z + ly * Math.sin(orbitTilt));
                
                p.trailPoints.push(p.mesh.position.clone());
                if (p.trailPoints.length > 200) p.trailPoints.shift();
                p.trail.geometry.setFromPoints(p.trailPoints);
            });

            if (Math.abs(starField.position.z - sun.position.z) > 3000) starField.position.z = sun.position.z;

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>

